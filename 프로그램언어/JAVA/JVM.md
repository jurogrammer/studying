## 출처

* https://d2.naver.com/helloworld/1230 (naver D2)

# JVM

### VM

프로그램을 실행하기 위해 물리적 머신(컴퓨터)과 유사한 머신을 소프트웨어로 구현한 것.



### JVM 특징

* WORA(Write Once Run Anyware)를 구현하기 위해 물리적 머신과 별개의 가상 머신을 기반으로 동작하도록 설계. 

* 스택 기반의 가상 머신
* 심볼릭 레퍼런스
  * 명시적인 메모리 주소 기반의 레퍼런스가 아닌 심볼릭 레퍼런스를 통해 참조
* 가비지 컬렉션
  * 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴
* 기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장
* 네트워크 바이트 오더
  * 리틀 엔디안이나 빅 엔디안 사이에서 플랫폼 독립성을 유지하기 위해 네트워크 바이트 오더 사용. (네트워크 바이트 오더는 빅엔디안)

### 자바 바이트 코드

사용자 언어인 자바와 기계어 사이의 중간인 바이트 코드 사용. 이 자바 바이트코드가 자바 코드를 배포하는 가장 작은 단위가 된다.

따라서 **자바 컴파일러는 기계어가 아닌 바이트코드로 변환한다.**



* JVM Vender들은 클래스 파일을 이해할수 있도록 역어셈블러 제공. (자바 어셈블리라 부름.)



* 자바 바이트 코드 명령어는 2가지로 분리할 수 있다.
  * 연산자
    * 1바이트 크기를 가진다.
    * 연산자의 특징에 따라 피연산자를 필요로 할 수 있다.
  * 피연산자
    * 2바이트의 크기를 가진다.



### 클래스 파일 포맷

#### 현상

한 메서드의 크기가 65535바이트를 넘을 수 없다는 JVM 명세 자체의 제한.

#### 원인

자바 바이트코드에서 일반적으로 사용하는 명령어 goto/jsr가 2바이트의 피연산자를 받음. 그래서 4바이트를 받는 goto_w나 jsr_w을 이미 준비하고 있으나 **다른 제한 사항** 때문에 자바 메서드는 65535바이트를 넘을 수 없음.



#### 클래스 파일 포맷

* magic
  * 4byte, 자바 클래스 파일을 구별하기 위해 미리 지정해둔 값
* minor_version, major_version
  * 2byte 씩, 클래스 버전
* constant_pool_count, constant_pool[]
  * 2byte, 클래스 파일의 상수 풀 정보를 기술.
  * jvm은 클래스 파일을 로드하면서 costant_pool의 정보를 메서드 영역의 런타임 상수 풀에 넣는다.
  * ox0028이면 총 40개를 가지고 있고 constant_pool은 최대 인덱스가 39이다.
* access_flags
  * 2byte, 주로 클래스의 modifier 정보 (public,final,abstract,interface)를 나타내는 플래그
* this_class, super_class
  * 각각 this,super에 해당하는 클래스들에 대한 constant_pool 내의 인덱스
* interfaces_count, interfaces[]
  * 클래스가 구현한 인터페이스의 개수와 각 인터페이스에 대한 constant_pool 내의 인덱스
* fields_count, fields[]
  * 클래스의 필드 개수와 정보
* method_count, methods[]
  * 클래스의 메서드 개수와 메서드 정보
* attributes_count, attributes[]
  * method_info 구조체는 다양한 속성을 갖고 있음.



javap 프로그램은 클래스 파일 또한 사용자가 읽을 수 있는 형태로 제공 해준다. 'javap -verbose'옵션을 사용하면 가능.



method_info에 보면 

LineNumberTable, LocalVaribable Table, exception_table의 길에 해당 값 모두 2byte로 고정되어 있음. 따라서 메서드의 크기는 해당 길이를 넘어설 수 없으므로 65535바이트로 제한 되어 있는 것.





### JVM 구조

Java Source가 Java Compiler에 의해 Java Byte Code로 컴파일됨.(.class파일)

Class Loader가 class파일을 런타임 데이터 영역에 로드 후, Excution Engine이 자바 바이트코드를 실행.



#### 클래스 로더

자바는 동적 로드를 함. 즉, 런타임 중 클래스를 처음으로 참조할 때 클래스를 로드하고 링크하는 특징을 가짐. 이 동적 클래스 로드를 담당하는 부분이 바로 클래스 로더이다.

#### 특징

* 계층 구조
  * 클래스 로더끼리 계층 구조로 생성 됨. 최상위 로더는 부트스트랩 클래스 로더
* 위임 모델
  * 클래스를 로드할 땐 먼저 상위 클래스 로더를 확인하여 클래스가 있는지 확인 후, 사용. 없다면 **로드를 요청 받은 클래스 로더가 클래스를 로드한다.**
* 가시성 제한
  * 하위 클래스 로더는 상위 클래스 로더를 찾을 수 있지만 그 역은 불가능.
* 언로드 불가
  * 클래스 로더 삭제 후 아예 새로운 클래스 로더를 생성해야 함.
* 각 클래스 로더는 로드된 클래스들을 보관하는 네임스페이스를 갖는다.
  * 클래스를 로드할 때 이미 로드된 클래스인지 확인하기 위해 네임스페이스에 보관된 FQCN을 기준으로 클래스를 찾음. 비록 FQCN이 같더라도 네임스페이스가 다르면, 즉 다른 클래스 로더가 로드한 클래스이면 다른 클래스로 간주.





### 클래스 로더 요청받을 시 작업

클래스 로더 캐시, 상위 클래스 로더, 자기 자신의 순서로 해당 클래스가 있는지 확인. 부트스트랩 클래스 로더까지 확인해도 없으면 요청 받은 클래스 로더가 파일 시스템에서 해당 클래스를 찾게 됨.



* 부스트 스트랩 로더
  * JVM기동할 때 생성.
  * Object 클래스들을 비롯하여 자바 API들을 로드
  * 다른 클래스 로더와 달리 자바가 아닌 Native 코드로 작성
* 익스텐션 클래스 로더
  * 기본 자바 API를 제외한 확장 클래스들을 로드
* 시스템 클래스 로더
  * 위처럼 JVM자체의 구성 요소들을 로드하는 것이 아닌, 애플리케이션의 클래스들을 로드. $CLASSPATH 내의 클래스들을 로드함.
* 사용자 정의 클래스 로더
  * 애플리케이션 사용자가 직접 코드 상에서 사용하는 클래스



### 클래스 로더가 클래스를 로드하는 과정

1. Loading
   * 클래스를 파일에서 가져와서 JVM의 메모리에 로드
2. Linking
   1. Verifying
      * 읽어 들인 클래스가 자바 언어 명세 및 JVM 명세에 명시된 대로 잘 되어 있는지 검사.
   2. Preparing
      * 클래스가 필요로 하는 메모리를 할당, 클래스에서 정의된 필드, 메서드, 인터페이스들을 나타내는 데이터 구조를 준비
   3. Resolving(분석)
      * 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
3. Initializing
   * 클래스 변수들을 적절한 값으로 초기화. 즉, static initializer들을 수행하고 static 필드들을 설정된 값으로 초기화 한다.



### 런타임 데이터 영역

JVM이라는 프로그램이 운영체제 위에서 실행되면서 할당 받은 메모리 영역.

총 6개의 영역으로 나뉨.

### Thread 독립적인 영역

* PC register

  * 현재 수행 중인 JVM 명령의 주소

* JVM 스택

  * 스택 프레임이라는 구조체를 저장하는 스택.
  * JVM은 오직 JVM스택에 스택프레임을 추가하고 제거하는 동작만 수행.

* 스택 프레임

  * JVM 내에서 메서드가 수행될 때마다 하나의 스택 프레임이 생성되어 해당 스레드의 JVM스택에 추가되고, 메서드가 종료되면 스택 프레임이 제거됨.

  * 각 스택 프레임이 가지는 정보

    * 지역 변수 배열

      0부터 시작하는 인덱스를 가지는 배열. 0은 메서드가 속한 클래스 인스턴스의 **this 레퍼런스**. 1부터는 메서드에 **전달된 파라미터들**이 저장되며 그 이후엔 **메서드의 지역 변수들이 저장**됨.

    * 피연산자 스택

      메서드의 실제 작업 공간

      각 메서드는 피연산자 스택과 지역 변수 배열 사이에서 데이터를 교환하고, 다른 메서드 호출 결과를 추가(push)하거나 꺼냄(pop) 이 공간이 얼마나 필요할지는 컴파일 시 결정할 수 있음.

    * 현재 실행 중인 메서드가 속한 클래스의 런타임 상수 풀에 대한 레퍼런스

  * 지역 변수 배열, 피연산자 스택은 컴파일 시에 결정되므로 스택프레임의 크기도 메서드의 크기에 따라 고정됨.

* 네이티브 메서드 스택

  * 언어에 맞게 C/C++ 스택 생성

### Thread 공유 영역

* 메서드 영역
  * 모든 스레드가 공유하는 영역.
  * JVM이 시작될 때 생성
  * JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 정보, Static 변수, 메서드의 바이트 코드 등을 보관.
  * JVM 벤더 마다 다양한 형태로 구현
  * 오라클 핫스팟 JVM에서는 흔이 Permanent Generation이라고 불림.
  * 메서드 영역에 대한 가비지 컬렉션은 JVM 벤더의 선택사항.
* 런타임 상수 풀
  * 클래스 파일 포맷에서 constant_pool 테이블에 해당 하는 영역
  * 메서드 영역에 포함되는 영역이나, JVM 동작에서 가장 핵심적인 역할을 수행하는 곳
  * 각 클래스와 인터페이스의 상수뿐만이 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블.
  * 즉, 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조.
* 힙
  * 인스턴스 또는 객체를 저장하는 공간으로 가비지 컬렉션 대상.

